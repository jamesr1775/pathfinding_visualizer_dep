{"version":3,"sources":["PathfindingVisualizer/Node/Node.jsx","layout/Header.js","layout/Legend.js","algorithms/algorithmUtils.js","PathfindingVisualizer/PathfindingVisualizer.jsx","mazeGenAlgorithms/basicRandomMaze.js","mazeGenAlgorithms/stairMaze.js","mazeGenAlgorithms/recursiveMaze.js","algorithms/dijkstra.js","algorithms/breadthFirstSearch.js","algorithms/astar.js","algorithms/greedy.js","App.js","serviceWorker.js","index.js"],"names":["Node","this","props","col","isFinish","isStart","isWall","onMouseDown","onMouseEnter","onMouseUp","row","extraClassName","id","className","e","Component","algorithms","label","value","patterns","Header","handleChangeAlgorithm","selectAlgorithm","handleChangeMaze","selectMaze","style","headerStyle","placeholder","options","styles","dropDownStyles","theme","colors","primary25","onChange","buttonStyle","onClick","visualizeAlgorithm","getClearPath","getClearWalls","getClearGrid","background","color","fontSize","paddingTop","borderRadius","textAlign","padding","display","control","base","state","isFocused","borderColor","boxShadow","menu","menuList","singleValue","Legend","sortNodesByDistance","unvisitedNodes","sort","nodeA","nodeB","distance","sortNodesByTotalDistance","totDistance","updateUnvisitedNeighbors","node","grid","unvisitedNeighbors","getUnvisitedNeighbors","neighbor","previousNode","updateUnvisitedNeighborsAStar","goal","hDist","heuristicDistance","temp","updateUnvisitedNeighborsGreedy","neighbors","push","length","filter","isVisited","xOne","yOne","xTwo","yTwo","Math","abs","getAllNodes","nodes","PathfindingVisualizer","Infinity","element","document","getElementById","setState","algorithm","querySelector","innerHTML","maze","getBasicRandomMaze","getStairMaze","getRecursiveMaze","NUM_GRID_ROWS","NUM_GRID_COLS","maxRows","maxCols","floor","random","generateBasicRandomMaze","currentRow","directionUp","generateStairMaze","moveStartPos","startRow","startCol","mouseIsPressed","moveFinishPos","lastNodeWasWall","finishRow","finishCol","getInitialGrid","preventDefault","currentNode","getNewGridWithWallToggled","currentElement","lastStartNode","lastFinishNode","visitedNodesInOrder","nodesInShortestPathOrder","i","setTimeout","animateShortestPath","rowStart","rowEnd","colStart","colEnd","orientation","surroundingwalls","generateRecursiveMaze","possibleRows","possibleCols","randRowIdx","randColIdx","colRand","randRow","currentCol","startNode","finishNode","utils","closestNode","shift","dijkstra","queue","nodeQueued","map","forEach","neighbour","breadthFirstSearch","astar","greedy","unshift","getNodesInShortestPathOrder","animateAlgorithm","bind","rowIdx","key","nodeIdx","handleMouseDown","handleMouseEnter","handleMouseUp","createNode","App","Boolean","window","location","hostname","match","ReactDOM","render","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.d6d899f7.chunk.js","sourcesContent":["import React, { Component } from \"react\";\n\nimport \"./Node.css\";\n\nexport default class Node extends Component {\n  render() {\n    const { col, isFinish, isStart, isWall, onMouseDown, onMouseEnter, onMouseUp, row } = this.props;\n    const extraClassName = isFinish ? \"node-finish\" : isStart ? \"node-start\" : isWall ? \"node-wall\" : \"\";\n\n    return (\n      <div\n        id={`node-${row}-${col}`}\n        className={`node ${extraClassName}`}\n        onMouseDown={(e) => onMouseDown(e, row, col)}\n        onMouseEnter={(e) => onMouseEnter(e, row, col)}\n        onMouseUp={(e) => onMouseUp(e)}\n      ></div>\n    );\n  }\n}\n","import React, { Component } from \"react\";\nimport Select from \"react-select\";\nimport PropTypes from \"prop-types\";\nimport \"./Header.css\";\n\nconst algorithms = [\n  { label: \"Dijstra's Algorithm\", value: 1 },\n  { label: \"Breadth First Search\", value: 2 },\n  { label: \"A* Algorithm\", value: 3 },\n  { label: \"Greedy Algorithm\", value: 4 },\n  // { label: \"Depth First Search\", value: 5 },\n];\nconst patterns = [\n  { label: \"Basic Random Maze\", value: 1 },\n  { label: \"Simple Stair Pattern\", value: 2 },\n  { label: \"Recursive Maze Pattern\", value: 3 },\n];\nexport class Header extends Component {\n  handleChangeAlgorithm = (e) => {\n    this.props.selectAlgorithm(e.label);\n  };\n  handleChangeMaze = (e) => {\n    this.props.selectMaze(e.label);\n  };\n\n  render() {\n    return (\n      <header>\n        <h1 style={headerStyle}>\n          <div className=\"container\">\n            <div className=\"row\">\n              <div className=\"dropdown\" style={headerStyle}>\n                Pathfinding Visualizer\n              </div>\n              <div className=\"dropdown\">\n                <Select\n                  placeholder={\"Select Algorithm\"}\n                  options={algorithms}\n                  styles={dropDownStyles}\n                  theme={(theme) => ({\n                    ...theme,\n                    colors: {\n                      ...theme.colors,\n                      primary25: \"teal\",\n                    },\n                  })}\n                  onChange={this.handleChangeAlgorithm}\n                />\n              </div>\n              <div className=\"dropdown\">\n                <Select\n                  placeholder={\"Mazes & Patterns\"}\n                  options={patterns}\n                  styles={dropDownStyles}\n                  theme={(theme) => ({\n                    ...theme,\n                    colors: {\n                      ...theme.colors,\n                      primary25: \"teal\",\n                    },\n                  })}\n                  onChange={this.handleChangeMaze}\n                />\n              </div>\n              <button style={buttonStyle} id=\"VisBtn\" onClick={() => this.props.visualizeAlgorithm()}>\n                Visualize\n              </button>\n              <button style={buttonStyle} onClick={() => this.props.getClearPath()}>\n                Clear Path\n              </button>\n              <button style={buttonStyle} onClick={() => this.props.getClearWalls()}>\n                Clear Walls\n              </button>\n              <button style={buttonStyle} onClick={() => this.props.getClearGrid()}>\n                Clear Grid\n              </button>\n            </div>\n          </div>\n        </h1>\n      </header>\n    );\n  }\n}\n\nexport default Header;\n\nHeader.propTypes = {\n  selectAlgorithm: PropTypes.func.isRequired,\n  selectMaze: PropTypes.func.isRequired,\n  visualizeAlgorithm: PropTypes.func.isRequired,\n  algorithm: PropTypes.object.isRequired,\n  getClearPath: PropTypes.func.isRequired,\n  getClearWalls: PropTypes.func.isRequired,\n  getClearGrid: PropTypes.func.isRequired,\n  grid: PropTypes.object.isRequired,\n};\n\nconst headerStyle = {\n  background: \"#34495e\",\n  color: \"#fff\",\n  fontSize: \"24px\",\n  paddingTop: \"3px\",\n};\n\nconst buttonStyle = {\n  borderRadius: \"4px\",\n  color: \"black\",\n  textAlign: \"center\",\n  fontSize: \"18px\",\n  padding: \"10px\",\n  display: \"\",\n};\n\nconst dropDownStyles = {\n  control: (base, state) => ({\n    ...base,\n    background: \"#34495e\",\n    color: \"#fff\",\n    borderRadius: state.isFocused ? \"3px 3px 0 0\" : 3,\n    borderColor: state.isFocused ? \"#34495e\" : \"#34495e\",\n    boxShadow: state.isFocused ? null : null,\n    \"&:hover\": {\n      background: \"teal\",\n    },\n  }),\n  menu: (base) => ({\n    ...base,\n    background: \"#34495e\",\n    color: \"fff\",\n    padding: 0,\n  }),\n  menuList: (base) => ({\n    ...base,\n    background: \"#34495e\",\n    color: \"fff\",\n    padding: 0,\n  }),\n  singleValue: (base) => ({\n    ...base,\n    background: \"#34495e\",\n    color: \"fff\",\n    padding: 0,\n  }),\n};\n","import React, { Component } from \"react\";\n\nimport \"./Legend.css\";\nexport class Legend extends Component {\n  render() {\n    return (\n      <div>\n        <ul>\n          <li className=\"legendCol\">\n            <div className=\"start\"></div>Start Node\n          </li>\n          <li className=\"legendCol\">\n            <div className=\"finish\"></div>\n            End Node\n          </li>\n          <li className=\"legendCol\">\n            <div className=\"visited1\"></div>\n            <div className=\"visited2\"></div>\n            Visited Node\n          </li>\n          <li className=\"legendCol\">\n            <div className=\"unvisited\"></div>Unvisited Node\n          </li>\n          <li className=\"legendCol\">\n            <div className=\"shortestpath\"></div>\n            Shortest Path\n          </li>\n          <li className=\"legendCol\">\n            <div className=\"wall\"></div>\n            Wall Node\n          </li>\n        </ul>\n      </div>\n    );\n  }\n}\n\nexport default Legend;\n","export function sortNodesByDistance(unvisitedNodes) {\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\nexport function sortNodesByTotalDistance(unvisitedNodes) {\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.totDistance - nodeB.totDistance);\n}\n\nexport function updateUnvisitedNeighbors(node, grid) {\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n  for (const neighbor of unvisitedNeighbors) {\n    neighbor.distance = node.distance + 1;\n    neighbor.previousNode = node;\n  }\n}\n\nexport function updateUnvisitedNeighborsAStar(node, goal, grid) {\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n  for (const neighbor of unvisitedNeighbors) {\n    let hDist = heuristicDistance(neighbor, goal);\n    neighbor.distance = node.distance + 1;\n    let temp = neighbor.distance + hDist;\n    if (temp < neighbor.totDistance) {\n      neighbor.totDistance = temp;\n    }\n    neighbor.previousNode = node;\n  }\n}\n\nexport function updateUnvisitedNeighborsGreedy(node, goal, grid) {\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n  for (const neighbor of unvisitedNeighbors) {\n    let hDist = heuristicDistance(neighbor, goal);\n    if (hDist < neighbor.totDistance) {\n      neighbor.distance = hDist;\n    }\n    neighbor.previousNode = node;\n  }\n}\n\nexport function getUnvisitedNeighbors(node, grid) {\n  const neighbors = [];\n  const { col, row } = node;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  return neighbors.filter((neighbor) => !neighbor.isVisited);\n}\n\nexport function heuristicDistance(nodeA, nodeB) {\n  let xOne = nodeA.row;\n  let yOne = nodeA.col;\n  let xTwo = nodeB.row;\n  let yTwo = nodeB.col;\n  let xDist = Math.abs(xOne - xTwo);\n  let yDist = Math.abs(yOne - yTwo);\n  return xDist + yDist;\n}\n\nexport function getAllNodes(grid) {\n  const nodes = [];\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n  return nodes;\n}\n\n// Backtracks from the finishNode to find the shortest path.\n// Only works when called *after* the dijkstra method above.\nexport function getNodesInShortestPathOrder(finishNode) {\n  const nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n}\n","import React, { Component } from \"react\";\nimport Node from \"./Node/Node\";\nimport Header from \"../layout/Header\";\nimport Legend from \"../layout/Legend\";\n\nimport { dijkstra } from \"../algorithms/dijkstra\";\nimport { breadthFirstSearch } from \"../algorithms/breadthFirstSearch\";\nimport { astar } from \"../algorithms/astar\";\nimport { greedy } from \"../algorithms/greedy\";\nimport { getNodesInShortestPathOrder } from \"../algorithms/algorithmUtils\";\n\nimport { generateBasicRandomMaze } from \"../mazeGenAlgorithms/basicRandomMaze\";\nimport { generateStairMaze } from \"../mazeGenAlgorithms/stairMaze\";\nimport { generateRecursiveMaze } from \"../mazeGenAlgorithms/recursiveMaze\";\n\nimport \"./PathfindingVisualizer.css\";\n\nconst NUM_GRID_ROWS = 30;\nconst NUM_GRID_COLS = 75;\n\nconst START_NODE_ROW = 14;\nconst START_NODE_COL = 9;\nconst FINISH_NODE_ROW = 14;\nconst FINISH_NODE_COL = 66;\n\nexport default class PathfindingVisualizer extends Component {\n  constructor() {\n    super();\n\n    this.moveStartPos = false;\n    this.startRow = START_NODE_ROW;\n    this.startCol = START_NODE_COL;\n    this.mouseIsPressed = false;\n    this.moveFinishPos = false;\n    this.lastNodeWasWall = false;\n    this.finishRow = FINISH_NODE_ROW;\n    this.finishCol = FINISH_NODE_COL;\n\n    this.state = {\n      grid: [],\n      algorithm: \"\",\n      maze: \"\",\n    };\n  }\n\n  componentDidMount() {\n    const grid = getInitialGrid();\n    this.setState({ grid });\n  }\n\n  handleMouseDown(e, row, col) {\n    e.preventDefault();\n    const { grid, moveStartPos } = this.state;\n    let currentNode = grid[row][col];\n    // let currentElement = document.getElementById(`node-${row}-${col}`);\n\n    this.mouseIsPressed = true;\n    if (currentNode.isStart) {\n      this.moveStartPos = true;\n    } else if (currentNode.isFinish) {\n      this.moveFinishPos = true;\n    } else if (!moveStartPos) {\n      getNewGridWithWallToggled(grid, row, col);\n    }\n  }\n\n  handleMouseEnter(e, row, col) {\n    e.preventDefault();\n    const { grid } = this.state;\n    let currentNode = grid[row][col];\n    let currentElement = document.getElementById(`node-${row}-${col}`);\n    if (!this.mouseIsPressed) return;\n    if (this.moveStartPos) {\n      let lastStartNode = grid[this.startRow][this.startCol];\n      lastStartNode.isStart = false;\n      if (this.lastNodeWasWall) {\n        this.lastNodeWasWall = false;\n        lastStartNode.isWall = true;\n      }\n      let lastStartElement = document.getElementById(`node-${this.startRow}-${this.startCol}`);\n      lastStartElement.className = lastStartNode.isWall ? \"node node-wall\" : \"node node-unvisited\";\n      currentNode.isStart = true;\n      this.startRow = row;\n      this.startCol = col;\n      currentElement.className = \"node node-start\";\n      if (currentNode.isWall) {\n        this.lastNodeWasWall = true;\n        currentNode.isWall = false;\n      }\n    } else if (this.moveFinishPos) {\n      let lastFinishNode = grid[this.finishRow][this.finishCol];\n      lastFinishNode.isFinish = false;\n      if (this.lastNodeWasWall) {\n        this.lastNodeWasWall = false;\n        lastFinishNode.isWall = true;\n      }\n      let lastFinishElement = document.getElementById(`node-${this.finishRow}-${this.finishCol}`);\n      lastFinishElement.className = lastFinishNode.isWall ? \"node node-wall\" : \"node node-unvisited\";\n      currentNode.isFinish = true;\n      this.finishRow = row;\n      this.finishCol = col;\n      currentElement.className = \"node node-finish\";\n      if (currentNode.isWall) {\n        this.lastNodeWasWall = true;\n        currentNode.isWall = false;\n      }\n    } else {\n      getNewGridWithWallToggled(grid, row, col);\n    }\n  }\n\n  handleMouseUp(e) {\n    this.mouseIsPressed = false;\n    this.moveStartPos = false;\n    this.moveFinishPos = false;\n  }\n\n  animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder) {\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          this.animateShortestPath(nodesInShortestPathOrder);\n        }, 10 * i);\n        return;\n      }\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i];\n        document.getElementById(`node-${node.row}-${node.col}`).className = \"node node-visited\";\n      }, 10 * i);\n    }\n  }\n  animateMaze(visitedNodesInOrder) {\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i];\n        document.getElementById(`node-${node.row}-${node.col}`).className = \"node node-wall\";\n      }, 10 * i);\n    }\n  }\n  animateShortestPath(nodesInShortestPathOrder) {\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n      setTimeout(() => {\n        const node = nodesInShortestPathOrder[i];\n        document.getElementById(`node-${node.row}-${node.col}`).className = \"node node-shortest-path\";\n      }, 25 * i);\n    }\n  }\n\n  getClearPath = () => {\n    const grid = this.state.grid;\n    for (let row = 0; row < NUM_GRID_ROWS; row++) {\n      //const currentRow = [];\n      for (let col = 0; col < NUM_GRID_COLS; col++) {\n        const node = grid[row][col];\n        node.isVisited = false;\n        node.distance = Infinity;\n        node.totDistance = Infinity;\n        node.previousNode = null;\n        let element = document.getElementById(`node-${node.row}-${node.col}`);\n        if (node.isStart || node.isFinish) {\n          element.className = node.isStart ? \"node node-start\" : node.isFinish ? \"node node-finish\" : \"node \";\n        } else {\n          element.className = node.isWall ? \"node node-wall\" : \"node\";\n        }\n      }\n    }\n    this.setState({ grid });\n  };\n  getClearWalls = () => {\n    const grid = this.state.grid;\n    for (let row = 0; row < NUM_GRID_ROWS; row++) {\n      //const currentRow = [];\n      for (let col = 0; col < NUM_GRID_COLS; col++) {\n        const node = grid[row][col];\n        node.isVisited = false;\n        node.distance = Infinity;\n        node.totDistance = Infinity;\n        node.previousNode = null;\n        let element = document.getElementById(`node-${node.row}-${node.col}`);\n        if (node.isWall) {\n          node.isWall = false;\n          element.className = \"node \";\n        }\n      }\n    }\n    // this.setState({ grid });\n  };\n\n  getClearGrid = () => {\n    this.getClearPath();\n    this.getClearWalls();\n  };\n\n  selectAlgorithm = (algorithm) => {\n    document.querySelector(\"#VisBtn\").innerHTML = `Visualize ${algorithm}`;\n    this.setState({ algorithm: algorithm });\n  };\n\n  selectMaze = (maze) => {\n    this.getClearWalls();\n    this.getClearPath();\n    //this.setState({ maze: maze });\n    if (maze === \"Basic Random Maze\") {\n      this.getBasicRandomMaze();\n    } else if (maze === \"Simple Stair Pattern\") {\n      this.getStairMaze();\n    } else if (maze === \"Recursive Maze Pattern\") {\n      this.getRecursiveMaze(2, NUM_GRID_ROWS - 3, 2, NUM_GRID_COLS - 3, \"horizontal\", false, NUM_GRID_ROWS, NUM_GRID_COLS);\n    }\n  };\n\n  getBasicRandomMaze = () => {\n    const grid = this.state.grid;\n    generateBasicRandomMaze(grid, NUM_GRID_ROWS, NUM_GRID_COLS);\n    this.setState({ grid });\n  };\n  getStairMaze = () => {\n    const grid = this.state.grid;\n    generateStairMaze(grid, NUM_GRID_ROWS, NUM_GRID_COLS);\n    this.setState({ grid });\n  };\n\n  getRecursiveMaze(rowStart, rowEnd, colStart, colEnd, orientation, surroundingwalls, maxRows, maxCols) {\n    const grid = this.state.grid;\n    generateRecursiveMaze(grid, rowStart, rowEnd, colStart, colEnd, orientation, surroundingwalls, maxRows, maxCols);\n    for (let row = 0; row < maxRows; row++) {\n      for (let col = 0; col < maxCols; col++) {\n        const node = grid[row][col];\n        if (node.isStart) {\n          document.getElementById(`node-${node.row}-${node.col}`).className = \"node node-start\";\n        } else if (node.isFinish) {\n          document.getElementById(`node-${node.row}-${node.col}`).className = \"node node-finish\";\n        } else if (node.isWall) {\n          document.getElementById(`node-${node.row}-${node.col}`).className = \"node node-wall\";\n        } else {\n          document.getElementById(`node-${node.row}-${node.col}`).className = \"node \";\n        }\n      }\n    }\n    this.setState({ grid });\n  }\n\n  visualizeAlgorithm() {\n    const { grid, algorithm } = this.state;\n    const startNode = grid[this.startRow][this.startCol];\n    const finishNode = grid[this.finishRow][this.finishCol];\n    let visitedNodesInOrder;\n    if (algorithm === \"Dijstra's Algorithm\") {\n      visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\n    } else if (algorithm === \"Breadth First Search\") {\n      visitedNodesInOrder = breadthFirstSearch(grid, startNode, finishNode);\n    } else if (algorithm === \"A* Algorithm\") {\n      visitedNodesInOrder = astar(grid, startNode, finishNode);\n    } else if (algorithm === \"Greedy Algorithm\") {\n      visitedNodesInOrder = greedy(grid, startNode, finishNode);\n    } else {\n      document.querySelector(\"#VisBtn\").innerHTML = \"Pick Algorithm\";\n      return;\n    }\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n    this.animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\n  }\n\n  render() {\n    const { grid, mouseIsPressed } = this.state;\n\n    return (\n      <>\n        {/* <div> */}\n        <Header\n          selectAlgorithm={this.selectAlgorithm}\n          selectMaze={this.selectMaze}\n          algorithm={this.state.algorithm}\n          visualizeAlgorithm={this.visualizeAlgorithm.bind(this)}\n          getClearPath={this.getClearPath}\n          getClearWalls={this.getClearWalls}\n          getClearGrid={this.getClearGrid}\n        >\n          {\" \"}\n        </Header>\n        <Legend></Legend>\n        <div className=\"grid\">\n          {grid.map((row, rowIdx) => {\n            return (\n              <div key={rowIdx}>\n                {row.map((node, nodeIdx) => {\n                  const { row, col, isFinish, isStart, isWall } = node;\n                  return (\n                    <Node\n                      key={nodeIdx}\n                      col={col}\n                      isFinish={isFinish}\n                      isStart={isStart}\n                      isWall={isWall}\n                      mouseIsPressed={mouseIsPressed}\n                      onMouseDown={(e, row, col) => this.handleMouseDown(e, row, col)}\n                      onMouseEnter={(e, row, col) => this.handleMouseEnter(e, row, col)}\n                      onMouseUp={(e, row, col) => this.handleMouseUp(e, row, col)}\n                      row={row}\n                    ></Node>\n                  );\n                })}\n              </div>\n            );\n          })}\n        </div>\n      </>\n    );\n  }\n}\n\nconst getInitialGrid = () => {\n  const grid = [];\n  for (let row = 0; row < NUM_GRID_ROWS; row++) {\n    const currentRow = [];\n    const isWall = false;\n    for (let col = 0; col < NUM_GRID_COLS; col++) {\n      currentRow.push(createNode(col, row, isWall));\n    }\n    grid.push(currentRow);\n  }\n  return grid;\n};\n\nconst createNode = (col, row, isWall) => {\n  return {\n    col,\n    row,\n    isStart: row === START_NODE_ROW && col === START_NODE_COL,\n    isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\n    distance: Infinity,\n    totDistance: Infinity,\n    isVisited: false,\n    isWall: isWall,\n    previousNode: null,\n  };\n};\n\nconst getNewGridWithWallToggled = (grid, row, col) => {\n  let currentNode = grid[row][col];\n  let element = document.getElementById(`node-${row}-${col}`);\n  if (!currentNode.isStart && !currentNode.isFinish) {\n    currentNode.isWall = !currentNode.isWall;\n    element.className = currentNode.isWall ? \"node node-wall\" : \"node node-unvisited\";\n  }\n};\n","export function generateBasicRandomMaze(grid, maxRows, maxCols) {\n  for (let row = 0; row < maxRows; row++) {\n    for (let col = 0; col < maxCols; col++) {\n      let isWall = Math.floor(Math.random() * 10);\n      const node = grid[row][col];\n      if (!node.isStart && !node.isFinish) {\n        node.isWall = isWall > 6 ? true : false;\n      }\n      node.isVisited = false;\n      node.distance = Infinity;\n      node.totDistance = Infinity;\n      node.previousNode = null;\n      if (node.isStart) {\n        document.getElementById(`node-${node.row}-${node.col}`).className = \"node node-start\";\n      } else if (node.isFinish) {\n        document.getElementById(`node-${node.row}-${node.col}`).className = \"node node-finish\";\n      } else if (node.isWall) {\n        document.getElementById(`node-${node.row}-${node.col}`).className = \"node node-wall\";\n      } else {\n        document.getElementById(`node-${node.row}-${node.col}`).className = \"node \";\n      }\n    }\n  }\n}\n","export function generateStairMaze(grid, maxRows, maxCols) {\n  let currentRow = maxRows - 1;\n  let directionUp = true;\n  for (let col = 0; col < maxCols - 1; col++) {\n    if (currentRow > 1 && directionUp) {\n      currentRow--;\n    } else if (currentRow < maxRows - 1 - 1 && !directionUp) {\n      currentRow++;\n    } else {\n      directionUp = !directionUp;\n    }\n    const node = grid[currentRow][col];\n    if (!node.isStart && !node.isFinish) {\n      node.isWall = true;\n    }\n    node.isVisited = false;\n    node.distance = Infinity;\n    node.totDistance = Infinity;\n    node.previousNode = null;\n    if (node.isStart) {\n      document.getElementById(`node-${node.row}-${node.col}`).className = \"node node-start\";\n    } else if (node.isFinish) {\n      document.getElementById(`node-${node.row}-${node.col}`).className = \"node node-finish\";\n    } else if (node.isWall) {\n      document.getElementById(`node-${node.row}-${node.col}`).className = \"node node-wall\";\n    } else {\n      document.getElementById(`node-${node.row}-${node.col}`).className = \"node \";\n    }\n  }\n}\n","export function generateRecursiveMaze(grid, rowStart, rowEnd, colStart, colEnd, orientation, surroundingwalls, maxRows, maxCols) {\n  if (rowEnd < rowStart || colEnd < colStart) {\n    return;\n  }\n  if (!surroundingwalls) {\n    for (let row = 0; row < maxRows; row++) {\n      for (let col = 0; col < maxCols; col++) {\n        if (row === 0 || row === maxRows - 1 || col === 0 || col === maxCols - 1) {\n          if (!grid[row][col].isStart && !grid[row][col].isFinish) {\n            grid[row][col].isWall = true;\n          }\n        }\n      }\n    }\n    surroundingwalls = true;\n  }\n  if (orientation === \"horizontal\") {\n    let possibleRows = [];\n    for (let i = rowStart; i <= rowEnd; i += 2) {\n      possibleRows.push(i);\n    }\n    let possibleCols = [];\n    for (let i = colStart - 1; i <= colEnd + 1; i += 2) {\n      possibleCols.push(i);\n    }\n    let randRowIdx = Math.floor(Math.random() * possibleRows.length);\n    let randColIdx = Math.floor(Math.random() * possibleCols.length);\n    let currentRow = possibleRows[randRowIdx];\n    let colRand = possibleCols[randColIdx];\n    for (let row = 0; row < maxRows; row++) {\n      for (let col = 0; col < maxCols; col++) {\n        const currentNode = grid[row][col];\n        if (\n          row === currentRow &&\n          col !== colRand &&\n          col >= colStart - 1 &&\n          col <= colEnd + 1 &&\n          !currentNode.isStart &&\n          !currentNode.isFinish\n        ) {\n          currentNode.isVisited = false;\n          currentNode.distance = Infinity;\n          currentNode.totDistance = Infinity;\n          currentNode.previousNode = null;\n          currentNode.isWall = true;\n        }\n      }\n    }\n    if (currentRow - 2 - rowStart > colEnd - colStart) {\n      generateRecursiveMaze(grid, rowStart, currentRow - 2, colStart, colEnd, orientation, surroundingwalls, maxRows, maxCols);\n    } else {\n      generateRecursiveMaze(grid, rowStart, currentRow - 2, colStart, colEnd, \"vertical\", surroundingwalls, maxRows, maxCols);\n    }\n    if (rowEnd - (currentRow + 2) > colEnd - colStart) {\n      generateRecursiveMaze(grid, currentRow + 2, rowEnd, colStart, colEnd, orientation, surroundingwalls, maxRows, maxCols);\n    } else {\n      generateRecursiveMaze(grid, currentRow + 2, rowEnd, colStart, colEnd, \"vertical\", surroundingwalls, maxRows, maxCols);\n    }\n  } else {\n    let possibleCols = [];\n    for (let i = colStart; i <= colEnd; i += 2) {\n      possibleCols.push(i);\n    }\n    let possibleRows = [];\n    for (let i = rowStart - 1; i <= rowEnd + 1; i += 2) {\n      possibleRows.push(i);\n    }\n\n    let randRowIdx = Math.floor(Math.random() * possibleRows.length);\n    let randColIdx = Math.floor(Math.random() * possibleCols.length);\n    let randRow = possibleRows[randRowIdx];\n    let currentCol = possibleCols[randColIdx];\n    for (let row = 0; row < maxRows; row++) {\n      for (let col = 0; col < maxCols; col++) {\n        const currentNode = grid[row][col];\n        if (\n          col === currentCol &&\n          row !== randRow &&\n          row >= rowStart - 1 &&\n          row <= rowEnd + 1 &&\n          !currentNode.isStart &&\n          !currentNode.isFinish\n        ) {\n          currentNode.isVisited = false;\n          currentNode.distance = Infinity;\n          currentNode.totDistance = Infinity;\n          currentNode.previousNode = null;\n          currentNode.isWall = true;\n        }\n      }\n    }\n    if (rowEnd - rowStart > currentCol - 2 - colStart) {\n      generateRecursiveMaze(grid, rowStart, rowEnd, colStart, currentCol - 2, \"horizontal\", surroundingwalls, maxRows, maxCols);\n    } else {\n      generateRecursiveMaze(grid, rowStart, rowEnd, colStart, currentCol - 2, orientation, surroundingwalls, maxRows, maxCols);\n    }\n    if (rowEnd - rowStart > colEnd - (currentCol + 2)) {\n      generateRecursiveMaze(grid, rowStart, rowEnd, currentCol + 2, colEnd, \"horizontal\", surroundingwalls, maxRows, maxCols);\n    } else {\n      generateRecursiveMaze(grid, rowStart, rowEnd, currentCol + 2, colEnd, orientation, surroundingwalls, maxRows, maxCols);\n    }\n  }\n}\n","import * as utils from \"./algorithmUtils\";\n\n// Performs Dijkstra's algorithm; returns *all* nodes in the order\n// in which they were visited. Also makes nodes point back to their\n// previous node, effectively allowing us to compute the shortest path\n// by backtracking from the finish node.\nexport function dijkstra(grid, startNode, finishNode) {\n  const visitedNodesInOrder = [];\n  startNode.distance = 0;\n  const unvisitedNodes = utils.getAllNodes(grid);\n  while (!!unvisitedNodes.length) {\n    utils.sortNodesByDistance(unvisitedNodes);\n    const closestNode = unvisitedNodes.shift();\n    // If we encounter a wall, we skip it.\n    if (closestNode.isWall) continue;\n    // If the closest node is at a distance of infinity,\n    // we must be trapped and should therefore stop.\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    utils.updateUnvisitedNeighbors(closestNode, grid);\n  }\n}\n","import * as utils from \"./algorithmUtils\";\n// Performs Breadth first search algorithm; returns *all* nodes in the order\n// in which they were visited. Also makes nodes point back to their\n// previous node, effectively allowing us to compute the shortest path\n// by backtracking from the finish node.\nexport function breadthFirstSearch(grid, startNode, finishNode) {\n  const visitedNodesInOrder = [];\n  startNode.distance = 0;\n  //const unvisitedNodes = getAllNodes(grid);\n  var queue = [startNode];\n  const nodeQueued = grid.map((row) => row.map((value) => false));\n\n  while (queue.length > 0) {\n    //sortNodesByDistance(unvisitedNodes);\n    const currentNode = queue.shift();\n    if (currentNode.isWall) continue;\n    currentNode.isVisited = true;\n    utils.updateUnvisitedNeighbors(currentNode, grid);\n\n    visitedNodesInOrder.push(currentNode);\n    let neighbouringNodes = utils.getUnvisitedNeighbors(currentNode, grid);\n    neighbouringNodes.forEach((neighbour) => {\n      let { col, row } = neighbour;\n      if (nodeQueued[row][col] === false) {\n        queue.push(neighbour);\n        nodeQueued[row][col] = true;\n      }\n    });\n\n    if (currentNode === finishNode) return visitedNodesInOrder;\n  }\n  return visitedNodesInOrder;\n}\n","import * as utils from \"./algorithmUtils\";\n\n// Performs Dijkstra's algorithm; returns *all* nodes in the order\n// in which they were visited. Also makes nodes point back to their\n// previous node, effectively allowing us to compute the shortest path\n// by backtracking from the finish node.\nexport function astar(grid, startNode, finishNode) {\n  const visitedNodesInOrder = [];\n  startNode.distance = 0;\n  startNode.totDistance =\n    startNode.distance + utils.heuristicDistance(startNode, finishNode);\n  const unvisitedNodes = utils.getAllNodes(grid);\n  while (!!unvisitedNodes.length) {\n    utils.sortNodesByTotalDistance(unvisitedNodes);\n    const closestNode = unvisitedNodes.shift();\n    // If we encounter a wall, we skip it.\n    if (closestNode.isWall) continue;\n    // If the closest node is at a distance of infinity,\n    // we must be trapped and should therefore stop.\n    if (closestNode.totDistance === Infinity) return visitedNodesInOrder;\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    utils.updateUnvisitedNeighborsAStar(closestNode, finishNode, grid);\n  }\n}\n","import * as utils from \"./algorithmUtils\";\n\n// Performs Dijkstra's algorithm; returns *all* nodes in the order\n// in which they were visited. Also makes nodes point back to their\n// previous node, effectively allowing us to compute the shortest path\n// by backtracking from the finish node.\nexport function greedy(grid, startNode, finishNode) {\n  const visitedNodesInOrder = [];\n  startNode.distance = utils.heuristicDistance(startNode, finishNode);\n  const unvisitedNodes = utils.getAllNodes(grid);\n  while (!!unvisitedNodes.length) {\n    utils.sortNodesByDistance(unvisitedNodes);\n    const closestNode = unvisitedNodes.shift();\n    // If we encounter a wall, we skip it.\n    if (closestNode.isWall) continue;\n    // If the closest node is at a distance of infinity,\n    // we must be trapped and should therefore stop.\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    utils.updateUnvisitedNeighborsGreedy(closestNode, finishNode, grid);\n  }\n}\n","import React from 'react';\nimport './App.css';\nimport PathfindingVisualizer from './PathfindingVisualizer/PathfindingVisualizer';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <PathfindingVisualizer></PathfindingVisualizer>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}